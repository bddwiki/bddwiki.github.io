<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BehaviourDrivenDevelopment on BDD Wiki</title><link>/</link><description>Recent content in BehaviourDrivenDevelopment on BDD Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>BehaviourDrivenProgrammingExample</title><link>/behaviourdrivenprogrammingexample/</link><pubDate>Sun, 21 Feb 2021 17:05:58 +0000</pubDate><guid>/behaviourdrivenprogrammingexample/</guid><description>In this example we have a banking application and we want to transfer balances between accounts. We’ll make this transfer using a BalanceTransferService class.
We’ll start, using the JUnit framework, where we’ll define a behaviour class:
public class BalancetransferServiceBehaviour extends TestCase { } Working from our PowerfulQuestions, the “next most important thing” we want is a simple balance transfer.
public class BalancetransferServiceBehaviour extends TestCase { public void shouldTransferBalanceFromAccountWithSufficientFunds() { ... } } We expect that whatever our implementation the result will be some interactions with a source and destination bank accounts, so we will provide two mock accounts, to support our specification of the expected behaviour and we’ll define what we expect to see in terms of these interactions.</description></item><item><title>BehaviourDrivenProgramming</title><link>/behaviourdrivenprogramming/</link><pubDate>Sun, 21 Feb 2021 17:02:29 +0000</pubDate><guid>/behaviourdrivenprogramming/</guid><description>BehaviourDrivenProgramming is a refinement and reframing of TestDrivenDevelopment that, amongst other things, helps speed the effective introduction of newcomers to the techniques and benefits of this approach to development.
By the time developers get to the stage where they are writing tests before writing the code, the tests are usually mainly state-based – asserting values at the end of the test method.
These test are often more like integration tests, hitting a database or requiring complex setup of state for each test, rather than the speedy unit tests we hope for.</description></item><item><title>BehaviourDrivenAnalysis</title><link>/behaviourdrivenanalysis/</link><pubDate>Sun, 21 Feb 2021 16:58:58 +0000</pubDate><guid>/behaviourdrivenanalysis/</guid><description>We explore how software can help address a business problem by asking, what are known as, PowerfulQuestions. This technique is intended to develop insight, and allows us to explore new avenues and better understand existing ones.
We approach BehaviourDrivenAnalysis in a structured way to minimise the risk of missing anything useful. Use Cases are a useful tool for establishing the boundaries of a system, in the sense of understanding what the system is (and more importantly is not) responsible for.</description></item><item><title>BehaviourDrivenCode</title><link>/behaviourdrivencode/</link><pubDate>Sun, 21 Feb 2021 16:57:21 +0000</pubDate><guid>/behaviourdrivencode/</guid><description>public class TimerSpec { public void shouldMeasureAPeriodOfTime() throws Exception { // setup Timer timer = new Timer(); timer.start(); // execute // TODO make this not time-dependent - could possibly fail Thread.sleep(10); timer.stop(); // verify Verify.that(timer.elapsedTimeMillis() &amp;gt; 0); } }</description></item><item><title>TheBddProcess</title><link>/thebddprocess/</link><pubDate>Sun, 21 Feb 2021 16:50:51 +0000</pubDate><guid>/thebddprocess/</guid><description>The BDD process looks like this:
A SubjectMatterExpert (typically a business user) works with a BusinessAnalyst to identify a business requirement. This is expressed as a story using the following template:
As a Role I request a Feature To gain a Benefit The speaker, who holds the Role, is the person who will gain the Benefit from the requested Feature.
This can also be paraphrased variously as &amp;hellip;</description></item><item><title>Introduction</title><link>/introduction/</link><pubDate>Sun, 21 Feb 2021 16:35:47 +0000</pubDate><guid>/introduction/</guid><description>TestDrivenDevelopment (TDD) has established itself as a useful&amp;ndash;and at its best, profound&amp;ndash;improvement in the software development process. It delivers a variety of benefits to its practitioners; some of them are related to testing, but the most important benefits are not.
Experienced practitioners, particularly those that have been involved in helping other developers learn the practice, note a life-cycle to TDD&amp;rsquo;s learning and adoption:
The developer starts writing unit tests around their code using a test framework like JUnit or NUnit.</description></item><item><title>TraditionalDevelopment</title><link>/traditionaldevelopment/</link><pubDate>Sun, 21 Feb 2021 16:15:09 +0000</pubDate><guid>/traditionaldevelopment/</guid><description>This is a term commonly used by AgileDevelopment practitioners to refer to other approaches to development.
This phrase encompasses a wide variety of development techniques, but to qualify a TraditionalDevelopment process needs to be based on the assumption that CostOfChange increases exponentially through the life of the project.
Such projects are usually run on a Waterfall development model, where development is divided up into a series of sequential phases through the life of the project.</description></item><item><title>AgileDevelopment</title><link>/agiledevelopment/</link><pubDate>Sun, 21 Feb 2021 16:00:04 +0000</pubDate><guid>/agiledevelopment/</guid><description>Agile Development is an approach to software development that attempts to reduce the cost of change, and so deliver software that meets business needs in a more predictable, timely manner.
It encompasses a variety of approaches and methods, but all share common features and are grounded in principles of the AgileManifesto.
Agile development practitioners believe that planning too far ahead is doomed to failure, because, however good we are, we are not prescient and we will make mistakes.</description></item><item><title>CostOfChange</title><link>/costofchange/</link><pubDate>Sun, 21 Feb 2021 15:43:50 +0000</pubDate><guid>/costofchange/</guid><description>TraditionalDevelopment projects are based on the assumption that CostOfChange will dramatically increase through the life of a project, driving the neccesity to try and anticipate problems, and do BigDesignUpFront in order to mitigate the risk of getting things wrong.
Projects using a more AgileDevelopment change the way they do things in order to flatten the CostOfChange curve, accepting that things may go wrong, they in effect say:
So if things probably will go wrong because we can&amp;rsquo;t guess the future, instead of trying to get better at predicting the future, let&amp;rsquo;s instead set things up to minimize the impact when the problem occurs!</description></item><item><title>TheSimplestThingThatCouldPossiblyWork</title><link>/thesimplestthingthatcouldpossiblywork/</link><pubDate>Sun, 21 Feb 2021 15:41:44 +0000</pubDate><guid>/thesimplestthingthatcouldpossiblywork/</guid><description>Agile developers attempt to avoid the common temptation to over-engineer solutions by holding to the doctrine of implementing the simplest solution that will fulfill the requirements.
This is a practice encouraged in ExtremeProgramming.</description></item><item><title>EnoughIsEnough</title><link>/enoughisenough/</link><pubDate>Sun, 21 Feb 2021 15:34:59 +0000</pubDate><guid>/enoughisenough/</guid><description>Many TraditionalDevelopment practices have predictions of what is expected to happen in future at their heart.
There is a law of diminishing returns at play, the more complex, detailed or the further into the future the guess, the less likely it is to be accurate.
People will be asked to guess something in enormous detail, requirements, design and project plans are all predicted in order to avoid the CostOfChange.
Although there are times when one must make an educated guess, the aim should be to minimize the time-horizon and scope of the guess, and to attempt to find a way to verify, or disprove the guess as soon as possible.</description></item><item><title>GettingTheWordsRight</title><link>/gettingthewordsright/</link><pubDate>Sun, 21 Feb 2021 15:27:22 +0000</pubDate><guid>/gettingthewordsright/</guid><description>BehaviourDrivenDevelopment (BDD) grew out of a thought experiment based on Neurolinguistic Programming (NLP) techniques. The idea is that the words you use influence the way you think about something.
As an example, when I was first getting to grips with TDD, I was pairing with an experienced agile coach, writing little test methods, then writing the code, and generally feeling good about life. Then I went ahead and wrote some code without a test.</description></item><item><title>NonFunctionalRequirements</title><link>/nonfunctionalrequirements/</link><pubDate>Thu, 18 Feb 2021 20:19:20 +0000</pubDate><guid>/nonfunctionalrequirements/</guid><description/></item><item><title>TechnicalStories</title><link>/technicalstories/</link><pubDate>Thu, 18 Feb 2021 20:17:19 +0000</pubDate><guid>/technicalstories/</guid><description/></item><item><title>SoftwareIndustryRecordOfFailure</title><link>/softwareindustryrecordoffailure/</link><pubDate>Thu, 18 Feb 2021 20:05:17 +0000</pubDate><guid>/softwareindustryrecordoffailure/</guid><description/></item><item><title>WheresTheBusinessValue</title><link>/wheresthebusinessvalue/</link><pubDate>Thu, 18 Feb 2021 20:04:45 +0000</pubDate><guid>/wheresthebusinessvalue/</guid><description>Every behaviour of a system should be there because it adds concretely to the business value of the system as a whole.
All too often software projects gain some kind of perverse impetus of their own, where features are added or technologies are chosen because they are &amp;ldquo;cool&amp;rdquo; or because the technical folk associated with the project feel that they are protecting their sponsors against some possible future requirements that the sponsors haven&amp;rsquo;t thought of or considered yet.</description></item><item><title>ItsAllBehaviour</title><link>/itsallbehaviour/</link><pubDate>Thu, 18 Feb 2021 20:03:41 +0000</pubDate><guid>/itsallbehaviour/</guid><description>Or more accurately, it&amp;rsquo;s all about what a system should do. BehaviourDrivenDevelopment is all about GettingTheWordsRight. We find that when we use a consistent vocabulary, much of the traditional disconnect between Business and Technology simply disappears.
Defining a system in terms of its behaviour works because it has different meanings at different levels of abstraction.</description></item><item><title>AcceptanceTestDrivenPlanning</title><link>/acceptancetestdrivenplanning/</link><pubDate>Thu, 18 Feb 2021 19:56:41 +0000</pubDate><guid>/acceptancetestdrivenplanning/</guid><description/></item><item><title>UbiquitousLanguage</title><link>/ubiquitouslanguage/</link><pubDate>Thu, 18 Feb 2021 17:55:25 +0000</pubDate><guid>/ubiquitouslanguage/</guid><description/></item><item><title>DomainDrivenDesign</title><link>/domaindrivendesign/</link><pubDate>Thu, 18 Feb 2021 17:52:26 +0000</pubDate><guid>/domaindrivendesign/</guid><description>Domain Driven Design is an approach to software design that focusses on the strengths of OO software development techniques to simulate the core of the problem at hand.
At its core it concentrates on building a simulation of the problem domain, minimizing technical influences, and attempting also to minimize misunderstandings between users of the software and the developers by establishing and using a common vocabulary (aka UbiquitousLanguage).
This approach has been in use by experienced programmers for many years, but has gained more prominence recently because of Eric Evans' excellent book by the same name.</description></item><item><title>TestDrivenDevelopment</title><link>/testdrivendevelopment/</link><pubDate>Thu, 18 Feb 2021 17:40:58 +0000</pubDate><guid>/testdrivendevelopment/</guid><description>Test Driven Development (aka TDD) is a programming technique that encourages an evolutionary approach to the design and development of a system.
It encourages programmers to write tests before they write the code that the tests interact with as a means of focusing the programmer&amp;rsquo;s attention on the problem that they are intending to solve rather than on the solution. This has many positive outcomes.
TDD is often associated with ExtremeProgramming.</description></item></channel></rss>